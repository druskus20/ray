use image::{DynamicImage, GenericImage};

use crate::{
    color::Color,
    object::Intersection,
    object::{Intersectable, Object},
    vector::Vector3,
};

#[derive(Debug, Clone)]
pub struct Light {
    pub direction: Vector3,
    pub color: Color,
    pub intensity: f32,
}

#[derive(Debug, Clone)]
pub struct Ray {
    pub origin: Vector3,
    pub direction: Vector3,
}

#[derive(Debug, Clone)]
pub struct Scene {
    pub objects: Vec<Object>,
    pub width: u32,
    pub height: u32,
    pub fov: f32,
    pub light: Light,
}

impl Scene {
    pub fn render(&self) -> DynamicImage {
        let mut image = DynamicImage::new_rgb8(self.width, self.height);
        let background = Color::new(100, 100, 100);
        for x in 0..self.width {
            for y in 0..self.height {
                let ray = self.spawn_prime_ray(x as f32, y as f32);
                image.put_pixel(x, y, background.to_rgba());
                if let Some(intersection) = self.trace_ray(&ray) {
                    let color = self.calc_color(&ray, &intersection);
                    image.put_pixel(x, y, color.to_rgba());
                }
            }
        }
        image
    }

    // Calculates the color generated by a ray
    pub fn calc_color(&self, ray: &Ray, intersection: &Intersection) -> Color {
        let distance = intersection.distance;
        let object = &intersection.object;
        let hit_point = ray.origin + (ray.direction * distance);
        let surface_normal = object.surface_normal(hit_point);
        let light_direction = -self.light.direction.normalize();

        // Amount of light that lands on the point
        let light_intensity = surface_normal.dot(&light_direction).max(0.0) * self.light.intensity;
        // Amount of light reflected
        let light_reflected = object.albedo() / std::f32::consts::PI;

        // Combine all: color of the point, color of the light, light intensity, and light reflected
        let res_color = Vector3::new(
            (object.color().red as f32 / 255.0) * (self.light.color.red as f32 / 255.0),
            (object.color().green as f32 / 255.0) * (self.light.color.green as f32 / 255.0),
            (object.color().blue as f32 / 255.0) * (self.light.color.blue as f32 / 255.0),
        );

        let res_color = res_color * light_intensity * light_reflected * 255.0;
        Color::new(res_color.x as u8, res_color.y as u8, res_color.z as u8)
    }

    pub fn spawn_prime_ray(&self, x: f32, y: f32) -> Ray {
        // + 0.5 to center the ray in the pixel
        let mut sensor_x = (x + 0.5) / self.width as f32;
        let mut sensor_y = (y + 0.5) / self.height as f32;

        // Convert coordinates to -1.0 to 1.0
        //  and flip y axis
        sensor_x = 2.0 * sensor_x - 1.0;
        sensor_y = 1.0 - (2.0 * sensor_y);

        // Adjust for the aspect ratio
        if self.width > self.height {
            let aspect_ratio = self.width as f32 / self.height as f32;
            sensor_x *= aspect_ratio;
        } else {
            let aspect_ratio = self.height as f32 / self.width as f32;
            sensor_y *= aspect_ratio;
        }

        // Adjust for the fov
        let fov_adj = (self.fov.to_radians() / 2.0).tan();
        sensor_x *= fov_adj;
        sensor_y *= fov_adj;

        Ray {
            origin: Vector3::zero(),
            direction: Vector3 {
                x: sensor_x,
                y: sensor_y,
                z: -1.0,
            }
            .normalize(),
        }
    }

    fn trace_ray(&self, ray: &Ray) -> Option<Intersection> {
        self.objects
            .iter()
            .filter_map(|o| o.intersect(ray))
            .min_by(|a, b| a.distance.partial_cmp(&b.distance).unwrap()) // TODO: handle None
    }
}
