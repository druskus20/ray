use image::{DynamicImage, GenericImage};

use crate::{
    color::Color, light::Light, object::Intersectable, object::Intersection, object::Object,
    vector::Vector3,
};

#[derive(Debug, Clone)]
pub struct Ray {
    pub origin: Vector3,
    pub direction: Vector3,
}

#[derive(Debug, Clone)]
pub struct Scene {
    pub objects: Vec<Object>,
    pub width: u32,
    pub height: u32,
    pub fov: f32,
    pub lights: Vec<Light>,
}

impl Scene {
    pub fn render(&self) -> DynamicImage {
        let mut image = DynamicImage::new_rgb8(self.width, self.height);
        let background = Color::new(100, 100, 100);
        for x in 0..self.width {
            for y in 0..self.height {
                let ray = self.spawn_prime_ray(x as f32, y as f32);
                image.put_pixel(x, y, background.to_rgba());
                if let Some(intersection) = self.trace_ray(&ray) {
                    let color = self.calc_color(&ray, &intersection);
                    image.put_pixel(x, y, color.to_rgba());
                }
            }
        }
        image
    }

    // Calculates the color generated by a ray
    pub fn calc_color(&self, ray: &Ray, intersection: &Intersection) -> Color {
        let distance = intersection.distance;
        let object = &intersection.object;
        let hit_point = ray.origin + (ray.direction * distance);
        let surface_normal = object.mesh.surface_normal(hit_point);
        let mut color = Vector3::zero();

        for light in &self.lights {
            let light_direction = light.direction(hit_point);

            let shadow_ray = Ray {
                // Shadow acne happens because of floating point values
                //  so we add an offset towards the outside of the object Shadow acne happens because
                //  of floating point values
                //   so we add an offset towards the outside of the object
                origin: hit_point + (surface_normal * 0.001),
                direction: light_direction,
            };

            // if there are no objects intersecting with the shadow ray
            let shadow_intersection = self.trace_ray(&shadow_ray);
            let is_in_light = shadow_intersection.is_none()
                || shadow_intersection.unwrap().distance > light.distance(hit_point);

            // Amount of light that lands on the point
            let light_intensity = if is_in_light {
                light.intensity(hit_point)
            } else {
                0.0
            };

            let light_intensity = surface_normal.dot(&light_direction).max(0.0) * light_intensity;
            // Amount of light reflected
            let light_reflected = object.material.albedo / std::f32::consts::PI;

            // Combine all: color of the point, color of the light, light intensity, and light reflected
            let res_color = Vector3::new(
                (object.material.color.red as f32 / 255.0) * (light.color().red as f32 / 255.0),
                (object.material.color.green as f32 / 255.0) * (light.color().green as f32 / 255.0),
                (object.material.color.blue as f32 / 255.0) * (light.color().blue as f32 / 255.0),
            );

            let res_color = res_color * light_intensity * light_reflected * 255.0;
            color = color + res_color;
        }
        Color::new(color.x as u8, color.y as u8, color.z as u8)
    }

    pub fn spawn_prime_ray(&self, x: f32, y: f32) -> Ray {
        // + 0.5 to center the ray in the pixel
        let mut sensor_x = (x + 0.5) / self.width as f32;
        let mut sensor_y = (y + 0.5) / self.height as f32;

        // Convert coordinates to -1.0 to 1.0
        //  and flip y axis
        sensor_x = 2.0 * sensor_x - 1.0;
        sensor_y = 1.0 - (2.0 * sensor_y);

        // Adjust for the aspect ratio
        if self.width > self.height {
            let aspect_ratio = self.width as f32 / self.height as f32;
            sensor_x *= aspect_ratio;
        } else {
            let aspect_ratio = self.height as f32 / self.width as f32;
            sensor_y *= aspect_ratio;
        }

        // Adjust for the fov
        let fov_adj = (self.fov.to_radians() / 2.0).tan();
        sensor_x *= fov_adj;
        sensor_y *= fov_adj;

        Ray {
            origin: Vector3::zero(),
            direction: Vector3 {
                x: sensor_x,
                y: sensor_y,
                z: -1.0,
            }
            .normalize(),
        }
    }

    fn trace_ray(&self, ray: &Ray) -> Option<Intersection> {
        self.objects
            .iter()
            .filter_map(|o| o.intersect(ray))
            .min_by(|a, b| a.distance.partial_cmp(&b.distance).unwrap()) // TODO: handle None
    }
}
